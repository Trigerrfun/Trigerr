<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vegan Cobra</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            background: radial-gradient(ellipse at 60% 40%, #6ee7b7 60%, #4ec46e 100%);
            font-family: 'Fredoka One', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        .top-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            z-index: 3;
        }
        .game-title {
            color: #fff;
            text-shadow: 2px 2px 0 #2e7d32;
            font-size: 1.8rem;
            margin: 0;
        }
        .settings-button {
            background: #ffe066;
            border: 3px solid #e1b900;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 3px #e1b900;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #388e3c;
        }
        .settings-menu {
            display: none;
            position: absolute;
            top: 60px;
            right: 10px;
            background-color: #fffbe6;
            border-radius: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 10px;
            z-index: 10;
            flex-direction: column;
            gap: 8px;
        }
        .menu-button {
            background: #4ec46e;
            color: #fff;
            border: none;
            border-radius: 12px;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 3px #388e3c;
            font-family: 'Fredoka One', cursive;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }
        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 1px #388e3c;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 1vh;
            width: 100%;
            max-width: 100vw;
            z-index: 2;
        }
        .responsive-canvas-wrapper {
            width: 96vw;
            max-width: 500px;
            aspect-ratio: 1/1;
            position: relative;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 32px;
            box-shadow: 0 10px 32px rgba(0,0,0,0.18);
            background: transparent;
            touch-action: none;
        }
        .controls-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 96vw;
            max-width: 500px;
            margin: 10px auto;
        }
        .level-display, .score-display, .time-display {
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 1px 1px 0 #2e7d32;
            padding: 0 10px;
        }
        .game-button {
            background: #ffe066;
            border: 3px solid #e1b900;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 1.2rem;
            margin-left: 10px;
            cursor: pointer;
            box-shadow: 0 4px #e1b900;
            transition: transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .game-button:active {
            transform: translateY(3px);
            box-shadow: 0 1px #e1b900;
        }
        .message-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .message-box {
            background: #fffbe6;
            border-radius: 24px;
            padding: 32px 40px;
            box-shadow: 0 0 0 8px #ffe066;
            text-align: center;
            max-width: 90vw;
            transform: scale(0.8);
            opacity: 0;
            transition: transform 0.25s cubic-bezier(.68,-0.55,.27,1.55), opacity 0.25s;
        }
        .message-overlay[style*="flex"] .message-box {
            transform: scale(1);
            opacity: 1;
        }
        .message-box h2 {
            margin: 0 0 10px 0;
            color: #388e3c;
            font-size: 2.2rem;
        }
        .message-box p {
            color: #333;
            font-size: 1.1rem;
        }
        .message-buttons {
            margin-top: 20px;
        }
        .modal-button {
            background: #4ec46e;
            color: #fff;
            border: none;
            border-radius: 12px;
            padding: 12px 28px;
            font-size: 1.2rem;
            margin: 0 10px;
            cursor: pointer;
            box-shadow: 0 3px #388e3c;
            font-family: 'Fredoka One', cursive;
        }
        .modal-button:active {
            transform: translateY(2px);
            box-shadow: 0 1px #388e3c;
        }
        .dpad-container {
            display: none;
            position: relative;
            width: 150px;
            height: 150px;
            margin-top: 20px;
        }
        .dpad-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: #fbe6b2;
            border: 3px solid #e1b900;
            border-radius: 10px;
            font-size: 1.8rem;
            font-family: 'Fredoka One', cursive;
            color: #388e3c;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px #e1b900;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }
        .dpad-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #e1b900;
        }
        .dpad-up { top: 0; left: 50px; }
        .dpad-down { bottom: 0; left: 50px; }
        .dpad-left { left: 0; top: 50px; }
        .dpad-right { right: 0; top: 50px; }

        @media (max-width: 600px) and (orientation: portrait) {
            .game-title { font-size: 1.5rem; }
            .message-box { padding: 18px 6vw; }
            .controls-info { font-size: 1rem; }
            .game-button { width: 40px; height: 40px; font-size: 1rem; }
            .dpad-container { display: block; }
        }
        @media (max-width: 900px) and (orientation: landscape) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
                gap: 20px;
                margin-top: 1vh;
            }
            .game-column {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .responsive-canvas-wrapper {
                 width: auto;
                 height: 75vh;
            }
            .dpad-container {
                display: block;
                margin-top: 0;
                position: relative;
                top: 20px;
            }
            .game-title { margin-top: 0; font-size: 1.8rem; }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <h1 class="game-title">Vegan Cobra</h1>
        <button id="pauseButton" class="settings-button" title="Pause" aria-label="Pause">
            <span id="pauseIcon">&#9208;</span>
            <span id="playIcon" style="display:none">&#9654;</span>
        </button>
        <button id="settingsButton" class="settings-button" title="Settings" aria-label="Settings">
            <span>&#9881;</span>
        </button>
        <div id="settingsMenu" class="settings-menu">
            <button id="soundButton" class="menu-button" title="Toggle Sound">
                <span id="soundOnIcon">&#128266;</span>
                <span id="soundOffIcon" style="display:none">&#128263;</span>
                Sound
            </button>
            <button id="homeButton" class="menu-button" title="Home">
                <span>&#8962;</span> Home
            </button>
            <button id="shareButton" class="menu-button" title="Share">
                <span>&#128279;</span> Share
            </button>
        </div>
    </div>

    <div class="game-container">
        <div class="game-column">
            <div class="responsive-canvas-wrapper">
                <canvas id="gameCanvas" width="500" height="500"></canvas>
            </div>
            <div class="controls-info">
                <div id="scoreDisplay" class="score-display">Score: 0</div>
                <div id="levelDisplay" class="level-display">Level: 1</div>
                <div id="timeDisplay" class="time-display">Time: 0s</div>
                <button id="resetButton" class="game-button" title="Reset Level" aria-label="Reset Level">&#8635;</button>
            </div>
        </div>
        <div class="dpad-container">
            <button id="dpad-up" class="dpad-button dpad-up" aria-label="Move Up">&#9650;</button>
            <button id="dpad-down" class="dpad-button dpad-down" aria-label="Move Down">&#9660;</button>
            <button id="dpad-left" class="dpad-button dpad-left" aria-label="Move Left">&#9664;</button>
            <button id="dpad-right" class="dpad-button dpad-right" aria-label="Move Right">&#9654;</button>
        </div>
    </div>

    <div id="messageOverlay" class="message-overlay">
        <div class="message-box">
            <h2 id="messageTitle"></h2>
            <p id="messageText"></p>
            <div id="messageButtons" class="message-buttons"></div>
        </div>
    </div>

    <audio id="eatSound" src="audio/eat.wav" preload="auto"></audio>
    <audio id="winSound" src="audio/win.wav" preload="auto"></audio>
    <audio id="gameOverSound" src="audio/gameover.wav" preload="auto"></audio>
    <audio id="touchSound" src="audio/touch.wav" preload="auto"></audio>
    
    <script>
    // --- Canvas & Context ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- DOM Elements ---
    const resetButton = document.getElementById('resetButton');
    const levelDisplay = document.getElementById('levelDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const timeDisplay = document.getElementById('timeDisplay');
    const messageOverlay = document.getElementById('messageOverlay');
    const messageTitle = document.getElementById('messageTitle');
    const messageText = document.getElementById('messageText');
    const messageButtons = document.getElementById('messageButtons');
    const dpadUp = document.getElementById('dpad-up');
    const dpadDown = document.getElementById('dpad-down');
    const dpadLeft = document.getElementById('dpad-left');
    const dpadRight = document.getElementById('dpad-right');
    const settingsButton = document.getElementById('settingsButton');
    const settingsMenu = document.getElementById('settingsMenu');
    const soundButton = document.getElementById('soundButton');
    const soundOnIcon = document.getElementById('soundOnIcon');
    const soundOffIcon = document.getElementById('soundOffIcon');
    const homeButton = document.getElementById('homeButton');
    const shareButton = document.getElementById('shareButton');
    const pauseButton = document.getElementById('pauseButton');
    const pauseIcon = document.getElementById('pauseIcon');
    const playIcon = document.getElementById('playIcon');
    
    // Audio DOM Elements
    const eatSound = document.getElementById('eatSound');
    const winSound = document.getElementById('winSound');
    const gameOverSound = document.getElementById('gameOverSound');
    const touchSound = document.getElementById('touchSound');

    // --- Audio Context for reliable playback ---
    let audioContext;
    let audioAutoplayInitiated = false; // Flag to track if audio context has been resumed

    // --- Game Constants ---
    const TILE_COUNT = 10;
    let GRID_SIZE = canvas.width / (TILE_COUNT + 2);
    const TIME_LIMIT_PER_FOOD = 10; // seconds per food item

    // --- Vegetable Emojis ---
    // A list of vegetable emojis to cycle through for 'veggie' food items.
    const VEGGIE_EMOJIS = ['ü•ï', 'ü•¶', 'üçÖ', 'ü•¨', 'üå∂Ô∏è', 'üåΩ', 'üçÜ', 'ü•î'];

    // --- Levels ---
    const LEVELS = [
        // Level 1: 2 foods (1 food, 1 veggie)
        { snake: [{x:1,y:6},{x:2,y:6},{x:3,y:6}], foods: [{x:8,y:8, type:'food'},{x:2,y:2, type:'veggie'}], walls: [], timeLimit: TIME_LIMIT_PER_FOOD * 2 },
        // Level 2: 4 foods (2 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:7,y:7, type:'food'},{x:1,y:8, type:'food'},{x:8,y:1, type:'veggie'}, {x:4,y:4, type:'veggie'}], walls: [{x:5,y:5}], timeLimit: TIME_LIMIT_PER_FOOD * 4 },
        // Level 3: 5 foods (3 food, 2 veggie)
        { snake: [{x:2,y:2},{x:2,y:3},{x:2,y:4}], foods: [{x:9,y:9, type:'food'},{x:2,y:9, type:'food'},{x:7,y:2, type:'food'}, {x:1,y:5, type:'veggie'}, {x:8,y:6, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3},{x:5,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 4: 4 foods (2 food, 2 veggie)
        { snake: [{x:1,y:8},{x:2,y:8},{x:3,y:8}], foods: [{x:8,y:1, type:'food'},{x:1,y:1, type:'food'}, {x:7,y:4, type:'veggie'}, {x:3,y:7, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:3},{x:4,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 4 },
        // Level 5: 5 foods (2 food, 1 speed, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:8,y:8, type:'food'},{x:5,y:5, type:'speed'},{x:2,y:7, type:'food'}, {x:9,y:3, type:'veggie'}, {x:0,y:6, type:'veggie'}], walls: [{x:4,y:4},{x:6,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 6: 5 foods (2 food, 1 invincible, 2 veggie)
        { snake: [{x:9,y:1},{x:8,y:1},{x:7,y:1}], foods: [{x:1,y:9, type:'food'},{x:5,y:5, type:'invincible'},{x:7,y:7, type:'food'}, {x:0,y:2, type:'veggie'}, {x:9,y:8, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 7: 4 foods (2 food, 2 veggie)
        { snake: [{x:1,y:5},{x:2,y:5},{x:3,y:5}], foods: [{x:8,y:5, type:'food'},{x:1,y:8, type:'food'}, {x:7,y:7, type:'veggie'}, {x:2,y:3, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3},{x:5,y:4},{x:5,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 4 },
        // Level 8: 5 foods (3 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:5,y:1, type:'food'}, {x:0,y:5, type:'veggie'}, {x:9,y:4, type:'veggie'}], walls: [{x:2,y:2},{x:2,y:3},{x:2,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 9: 5 foods (1 speed, 1 invincible, 3 veggie)
        { snake: [{x:5,y:5},{x:4,y:5},{x:3,y:5}], foods: [{x:1,y:1, type:'speed'},{x:9,y:9, type:'invincible'},{x:5,y:9, type:'veggie'}, {x:0,y:0, type:'veggie'}, {x:9,y:0, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 10: 4 foods (2 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:9,y:9, type:'food'},{x:1,y:9, type:'food'}, {x:0,y:8, type:'veggie'}, {x:8,y:0, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:2},{x:4,y:2},{x:5,y:2}], timeLimit: TIME_LIMIT_PER_FOOD * 4 },
        // Level 11: 5 foods (3 food, 2 veggie)
        { snake: [{x:0,y:1},{x:1,y:1},{x:2,y:1}], foods: [{x:9,y:1, type:'food'},{x:9,y:8, type:'food'},{x:0,y:8, type:'food'}, {x:5,y:0, type:'veggie'}, {x:5,y:9, type:'veggie'}], walls: [{x:4,y:4, type:'teleport',exitX:4,exitY:6},{x:4,y:6, type:'teleport',exitX:4,exitY:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 12: 5 foods (3 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:8,y:8, type:'food'},{x:1,y:8, type:'food'},{x:5,y:4, type:'food'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:5,y:5},{x:6,y:5},{x:7,y:5}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 13: 5 foods (3 food, 2 veggie)
        { snake: [{x:5,y:0},{x:5,y:1},{x:5,y:2}], foods: [{x:5,y:9, type:'food'},{x:9,y:5, type:'food'},{x:0,y:5, type:'food'}, {x:1,y:1, type:'veggie'}, {x:8,y:8, type:'veggie'}], walls: [{x:5,y:4},{x:5,y:5},{x:5,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 14: 4 foods (2 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:8,y:8, type:'food'},{x:2,y:8, type:'food'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:4,y:2},{x:4,y:3},{x:4,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 4 },
        // Level 15: 5 foods (1 speed, 1 invincible, 1 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:5,y:5, type:'speed'},{x:9,y:9, type:'invincible'},{x:1,y:9, type:'food'}, {x:0,y:5, type:'veggie'}, {x:9,y:5, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:3},{x:4,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 16: 5 foods (3 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:9,y:1, type:'food'}, {x:0,y:0, type:'veggie'}, {x:8,y:8, type:'veggie'}], walls: [{x:2,y:2},{x:2,y:3},{x:2,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 17: 5 foods (3 food, 2 veggie)
        { snake: [{x:0,y:1},{x:1,y:1},{x:2,y:1}], foods: [{x:9,y:1, type:'food'},{x:9,y:8, type:'food'},{x:0,y:8, type:'food'}, {x:5,y:0, type:'veggie'}, {x:5,y:9, type:'veggie'}], walls: [{x:4,y:4, type:'teleport',exitX:4,exitY:6},{x:4,y:6, type:'teleport',exitX:4,exitY:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 18: 5 foods (3 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:5,y:1, type:'food'}, {x:0,y:5, type:'veggie'}, {x:9,y:4, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:2},{x:4,y:2}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 19: 4 foods (2 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:8,y:8, type:'food'},{x:2,y:2, type:'food'}, {x:0,y:9, type:'veggie'}, {x:9,y:0, type:'veggie'}], walls: [{x:4,y:2},{x:4,y:3},{x:4,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 4 },
        // Level 20: 5 foods (1 speed, 1 invincible, 1 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:5,y:5, type:'speed'},{x:9,y:9, type:'invincible'},{x:1,y:9, type:'food'}, {x:0,y:0, type:'veggie'}, {x:9,y:0, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:3},{x:4,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 21: 6 foods (4 food, 2 veggie)
        { snake: [{x:5,y:5},{x:4,y:5},{x:3,y:5}], foods: [{x:1,y:1, type:'food'},{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:9,y:1, type:'food'}, {x:0,y:5, type:'veggie'}, {x:5,y:0, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3}], timeLimit: TIME_LIMIT_PER_FOOD * 6 },
        // Level 22: 5 foods (3 food, 2 veggie)
        { snake: [{x:1,y:5},{x:2,y:5},{x:3,y:5}], foods: [{x:8,y:5, type:'food'},{x:1,y:8, type:'food'},{x:5,y:1, type:'food'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 23: 6 foods (3 food, 1 speed, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:9,y:1, type:'food'},{x:5,y:5, type:'speed'}, {x:0,y:0, type:'veggie'}, {x:8,y:8, type:'veggie'}], walls: [{x:2,y:2},{x:2,y:3},{x:2,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 6 },
        // Level 24: 5 foods (3 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:9,y:1, type:'food'}, {x:0,y:5, type:'veggie'}, {x:9,y:5, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:2},{x:4,y:2}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 25: 8 foods (4 food, 1 speed, 1 invincible, 2 veggie)
        { snake: [{x:5,y:5},{x:4,y:5},{x:3,y:5}], foods: [{x:1,y:1, type:'food'},{x:9,y:9, type:'food'},{x:1,y:9, type:'food'},{x:9,y:1, type:'food'},{x:5,y:1, type:'speed'},{x:5,y:9, type:'invincible'}, {x:0,y:0, type:'veggie'}, {x:8,y:8, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3}], timeLimit: TIME_LIMIT_PER_FOOD * 8 },
        // Level 26: 5 foods (3 food, 2 veggie)
        { snake: [{x:2,y:2},{x:3,y:2},{x:4,y:2}], foods: [{x:7,y:7, type:'food'},{x:2,y:8, type:'food'},{x:8,y:2, type:'food'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:5,y:5},{x:6,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 27: 5 foods (2 food, 1 speed, 2 veggie)
        { snake: [{x:7,y:7},{x:7,y:8},{x:7,y:9}], foods: [{x:2,y:2, type:'food'},{x:8,y:8, type:'food'},{x:5,y:5, type:'speed'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:3,y:3},{x:6,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 28: 5 foods (2 food, 1 invincible, 2 veggie)
        { snake: [{x:1,y:8},{x:2,y:8},{x:3,y:8}], foods: [{x:8,y:1, type:'food'},{x:1,y:1, type:'food'},{x:5,y:5, type:'invincible'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:2,y:2},{x:3,y:3},{x:4,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 29: 5 foods (2 food, 1 speed, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:8,y:8, type:'food'},{x:5,y:5, type:'speed'},{x:2,y:7, type:'food'}, {x:0,y:0, type:'veggie'}, {x:9,y:9, type:'veggie'}], walls: [{x:4,y:4},{x:6,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 5 },
        // Level 30: 8 foods (4 food, 1 speed, 1 invincible, 2 veggie)
        { snake: [{x:0,y:0},{x:0,y:1},{x:0,y:2}], foods: [{x:1,y:1, type:'food'},{x:8,y:8, type:'food'},{x:1,y:8, type:'food'},{x:8,y:1, type:'food'},{x:5,y:0, type:'speed'},{x:5,y:9, type:'invincible'}, {x:0,y:5, type:'veggie'}, {x:9,y:5, type:'veggie'}], walls: [{x:5,y:2},{x:5,y:3},{x:5,y:4},{x:5,y:6},{x:5,y:7},{x:5,y:8},{x:2,y:5},{x:3,y:5},{x:4,y:5},{x:6,y:5},{x:7,y:5},{x:8,y:5}], timeLimit: TIME_LIMIT_PER_FOOD * 8 },
        // Level 31 (NEW) - Simple maze with multiple food items (4 food, 2 veggie)
        { snake: [{x:1,y:1},{x:2,y:1},{x:3,y:1}], foods: [{x:8,y:8, type:'food'},{x:1,y:8, type:'food'},{x:8,y:1, type:'food'},{x:5,y:5, type:'food'}, {x:0,y:4, type:'veggie'}, {x:9,y:6, type:'veggie'}], walls: [{x:2,y:4},{x:3,y:4},{x:4,y:4},{x:5,y:4},{x:7,y:6},{x:6,y:6},{x:5,y:6}], timeLimit: TIME_LIMIT_PER_FOOD * 6 },
        // Level 32 (NEW) - Boxed-in foods, requires strategic movement (2 food, 1 speed, 3 veggie)
        { snake: [{x:0,y:4},{x:1,y:4},{x:2,y:4}], foods: [{x:7,y:2, type:'food'},{x:2,y:7, type:'food'},{x:7,y:7, type:'speed'}, {x:1,y:1, type:'veggie'}, {x:8,y:1, type:'veggie'}, {x:1,y:8, type:'veggie'}], walls: [{x:4,y:0},{x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:5},{x:4,y:6},{x:4,y:7},{x:4,y:8},{x:4,y:9},{x:5,y:0},{x:5,y:9},{x:0,y:4},{x:9,y:4}], timeLimit: TIME_LIMIT_PER_FOOD * 6 },
        // Level 33 (NEW) - Scattered foods with some wall obstacles (4 food, 1 invincible, 3 veggie)
        { snake: [{x:4,y:4},{x:4,y:5},{x:4,y:6}], foods: [{x:0,y:0, type:'food'},{x:9,y:0, type:'food'},{x:0,y:9, type:'food'},{x:9,y:9, type:'food'},{x:5,y:5, type:'invincible'}, {x:1,y:5, type:'veggie'}, {x:8,y:5, type:'veggie'}, {x:5,y:1, type:'veggie'}], walls: [{x:1,y:1},{x:8,y:1},{x:1,y:8},{x:8,y:8}], timeLimit: TIME_LIMIT_PER_FOOD * 8 }
    ];

    // --- Game State ---
    let snake, foods, foodIndex, dx, dy, canMove, currentLevel;
    let gameState;
    let soundEnabled = true;
    let score = 0;
    let highScore = localStorage.getItem('veganCobraHighScore') || 0; // Updated localStorage key
    let gameTimer;
    let timeLeft;
    let isInvincible = false;
    let speedBoostActive = false;
    let invincibleTimeout;
    let speedBoostTimeout;
    let currentScoreAtLevelStart = 0; // To maintain score across levels

    // --- Dynamic Border Styling ---
    function getBorderStyle(level) {
        const hue = (level * 15) % 360;
        const primaryColor = `hsl(${hue}, 90%, 60%)`;
        const shadowColor = `hsl(${hue}, 70%, 45%)`;
        const fillColor = `hsl(${hue}, 100%, 75%)`;
        const widths = [2, 1, 1, 1];
        const lineWidth = widths[level % widths.length];
        const innerBoardFill = "#fbe6b2";
        return {
            strokeStyle: primaryColor,
            shadowColor: shadowColor,
            fillStyle: fillColor,
            lineWidth: lineWidth,
            innerFill: innerBoardFill,
        };
    }

    // --- Dynamic Snake Colors ---
    function getSnakeColor(level) {
        const baseHue = (level * 20) % 360; // Change hue based on level
        const headColor = `hsl(${baseHue}, 70%, 50%)`;
        const headStroke = `hsl(${baseHue}, 90%, 30%)`;
        const bodyColor = `hsl(${baseHue}, 60%, 70%)`;
        const bodyStroke = `hsl(${baseHue}, 80%, 40%)`;
        return { headFill: headColor, headStroke: headStroke, bodyFill: bodyColor, bodyStroke: bodyStroke };
    }

    // --- Dynamic Food Colors (for the apple background) ---
    function getFoodColor(level) {
        const baseHue = (level * 30 + 120) % 360; // Offset hue for food
        return `hsl(${baseHue}, 80%, 65%)`;
    }

    // --- Drawing Functions ---
    function drawGame() {
        const unscaledWidth = parseFloat(canvas.style.width) || canvas.width;
        GRID_SIZE = unscaledWidth / (TILE_COUNT + 2);
        const PADDING = GRID_SIZE;
        ctx.clearRect(0,0,canvas.width,canvas.height);

        const borderStyle = getBorderStyle(currentLevel);

        ctx.save();
        ctx.shadowColor = borderStyle.shadowColor;
        ctx.shadowBlur = 16;
        ctx.fillStyle = borderStyle.fillStyle;
        ctx.strokeStyle = borderStyle.strokeStyle;
        ctx.lineWidth = borderStyle.lineWidth;
        ctx.beginPath();
        ctx.roundRect(PADDING/2, PADDING/2, unscaledWidth-PADDING, unscaledWidth-PADDING, 32);
        ctx.fill();
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.fillStyle = borderStyle.innerFill;
        ctx.strokeStyle = borderStyle.strokeStyle;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(PADDING, PADDING, unscaledWidth-2*PADDING, unscaledWidth-2*PADDING, 18);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.07)";
        ctx.lineWidth = 1;
        for(let i=1;i<TILE_COUNT;i++) {
            ctx.beginPath();
            ctx.moveTo(PADDING + i*GRID_SIZE, PADDING);
            ctx.lineTo(PADDING + i*GRID_SIZE, unscaledWidth - PADDING);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(PADDING, PADDING + i*GRID_SIZE);
            ctx.lineTo(unscaledWidth - PADDING, PADDING + i*GRID_SIZE);
            ctx.stroke();
        }
        ctx.restore();

        // Walls
        const level = LEVELS[currentLevel];
        if(level.walls) {
            ctx.save();
            ctx.fillStyle = "#bdbdbd";
            ctx.strokeStyle = "#616161";
            ctx.lineWidth = 3;
            level.walls.forEach(wall=>{
                ctx.beginPath();
                ctx.roundRect(PADDING + wall.x*GRID_SIZE, PADDING + wall.y*GRID_SIZE, GRID_SIZE, GRID_SIZE, 8);
                ctx.fill();
                ctx.stroke();
                if (wall.type === 'teleport') {
                    ctx.save();
                    ctx.fillStyle = "rgba(100, 100, 255, 0.5)";
                    ctx.beginPath();
                    ctx.roundRect(PADDING + wall.x*GRID_SIZE + GRID_SIZE*0.1, PADDING + wall.y*GRID_SIZE + GRID_SIZE*0.1, GRID_SIZE*0.8, GRID_SIZE*0.8, 5);
                    ctx.fill();
                    ctx.font = `${GRID_SIZE * 0.5}px Fredoka One`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = "#fff";
                    ctx.fillText('üï≥Ô∏è', PADDING + wall.x*GRID_SIZE + GRID_SIZE/2, PADDING + wall.y*GRID_SIZE + GRID_SIZE/2 + 5);
                    ctx.restore();
                }
            });
            ctx.restore();
        }

        // Food & Power-ups
        // Only draw the current target food item
        if(foods && foods[foodIndex]) {
            const food = foods[foodIndex];
            const cx = PADDING + food.x*GRID_SIZE + GRID_SIZE/2;
            const cy = PADDING + food.y*GRID_SIZE + GRID_SIZE/2;
            const bounce = Math.sin(Date.now()/200) * GRID_SIZE * 0.08;
            ctx.save();
            ctx.beginPath();

            if (food.type === 'food') {
                // Draw the original apple-like food item
                ctx.arc(cx, cy + bounce, GRID_SIZE*0.32, 0, 2*Math.PI);
                ctx.fillStyle = getFoodColor(currentLevel); // Dynamic food color
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cx-GRID_SIZE*0.1, cy-GRID_SIZE*0.1 + bounce, GRID_SIZE*0.09, 0, 2*Math.PI);
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.fill();
                ctx.strokeStyle = "#795548";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy-GRID_SIZE*0.32 + bounce);
                ctx.lineTo(cx+GRID_SIZE*0.08, cy-GRID_SIZE*0.45 + bounce);
                ctx.stroke();
            } else if (food.type === 'veggie') {
                // Draw the vegetable emoji in an empty box
                ctx.font = `${GRID_SIZE * 0.6}px Fredoka One`; // Set font for emojis
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Calculate emoji index based on the number of 'veggie' foods encountered so far
                const veggieFoodsEatenCount = foods.slice(0, foodIndex).filter(f => f.type === 'veggie').length;
                const emojiIndex = veggieFoodsEatenCount % VEGGIE_EMOJIS.length;
                ctx.fillText(VEGGIE_EMOJIS[emojiIndex], cx, cy + bounce + 5);
            } else if (food.type === 'speed') {
                ctx.font = `${GRID_SIZE * 0.6}px Fredoka One`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = "#FFD700";
                ctx.fillText('‚ö°', cx, cy + bounce + 5);
            } else if (food.type === 'invincible') {
                ctx.font = `${GRID_SIZE * 0.6}px Fredoka One`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = "#87CEEB";
                ctx.fillText('üõ°Ô∏è', cx, cy + bounce + 5);
            }
            ctx.restore();
        }

        // Snake
        if(snake) {
            const snakeColors = getSnakeColor(currentLevel);
            for(let i=snake.length-1;i>=0;i--) {
                const seg = snake[i];
                const x = PADDING + seg.x*GRID_SIZE;
                const y = PADDING + seg.y*GRID_SIZE;
                ctx.save();
                if(i===0) {
                    ctx.fillStyle = isInvincible ? "#FF4500" : snakeColors.headFill;
                    ctx.strokeStyle = snakeColors.headStroke;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.roundRect(x+6, y+6, GRID_SIZE-12, GRID_SIZE-12, 18);
                    ctx.fill();
                    ctx.stroke();
                    const now = Date.now();
                    const blink = (Math.floor(now / 1800) % 5 === 0);
                    ctx.fillStyle = "#fff";
                    ctx.beginPath();
                    ctx.arc(x+GRID_SIZE*0.7, y+GRID_SIZE*0.32, GRID_SIZE*0.13, 0, 2*Math.PI);
                    ctx.arc(x+GRID_SIZE*0.38, y+GRID_SIZE*0.32, GRID_SIZE*0.13, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.fillStyle = "#222";
                    ctx.beginPath();
                    ctx.arc(x+GRID_SIZE*0.7, y+GRID_SIZE*0.32, GRID_SIZE*0.06, 0, 2*Math.PI);
                    ctx.arc(x+GRID_SIZE*0.38, y+GRID_SIZE*0.32, GRID_SIZE*0.06, 0, 2*Math.PI);
                    ctx.fill();
                    if (blink) {
                        ctx.fillStyle = isInvincible ? "#FF4500" : snakeColors.headFill;
                        ctx.beginPath();
                        ctx.ellipse(x+GRID_SIZE*0.7, y+GRID_SIZE*0.32, GRID_SIZE*0.13, GRID_SIZE*0.07, 0, 0, Math.PI*2);
                        ctx.ellipse(x+GRID_SIZE*0.38, y+GRID_SIZE*0.32, GRID_SIZE*0.13, GRID_SIZE*0.07, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.strokeStyle = "#222";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x+GRID_SIZE/2, y+GRID_SIZE*0.62, GRID_SIZE*0.13, 0, Math.PI);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = isInvincible ? "#FFA07A" : snakeColors.bodyFill;
                    ctx.strokeStyle = snakeColors.bodyStroke;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(x+8, y+8, GRID_SIZE-16, GRID_SIZE-16, 12);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
    }

    // --- Game Logic ---
    function update() {
        if(dx===0 && dy===0) return;
        let head = {x: snake[0].x+dx, y: snake[0].y+dy};
        const currentLevelData = LEVELS[currentLevel];

        // Teleport
        const teleportWall = currentLevelData.walls.find(w => w.type === 'teleport' && w.x === head.x && w.y === head.y);
        if (teleportWall) {
            head.x = teleportWall.exitX;
            head.y = teleportWall.exitY;
            playSound(eatSound); // Play sound on teleport
        }

        if(!isInvincible) {
            if(head.x<0||head.x>=TILE_COUNT||head.y<0||head.y>=TILE_COUNT) return endGame("Hit the edge!");
            if(currentLevelData.walls && currentLevelData.walls.some(w => w.x === head.x && w.y === head.y && w.type !== 'teleport')) return endGame("Bumped into a wall!");
            for(let i=1;i<snake.length;i++) {
                if(head.x===snake[i].x && head.y===snake[i].y) return endGame("Crossed your own path!");
            }
        } else {
            // Invincible mode wraps around the edges
            if(head.x<0) head.x = TILE_COUNT - 1;
            else if(head.x>=TILE_COUNT) head.x = 0;
            if(head.y<0) head.y = TILE_COUNT - 1;
            else if(head.y>=TILE_COUNT) head.y = 0;
            // In invincible mode, also ignore walls and self-collision visually, but for the game, still avoid
            if(currentLevelData.walls && currentLevelData.walls.some(w => w.x === head.x && w.y === head.y && w.type !== 'teleport')) {
                // If it's a non-teleport wall, just don't grow, but don't end game
                snake.pop(); // Still remove tail
                return;
            }
            for(let i=1;i<snake.length;i++) {
                if(head.x===snake[i].x && head.y===snake[i].y) {
                    snake.pop(); // Still remove tail, don't end game
                    return;
                }
            }
        }

        snake.unshift(head);

        // Check if the snake head is at the current target food location
        if(foods[foodIndex] && head.x===foods[foodIndex].x && head.y===foods[foodIndex].y) {
            playSound(eatSound);
            score += 10;
            updateScoreDisplay();
            const foodType = foods[foodIndex].type;
            if (foodType === 'speed') {
                activateSpeedBoost();
            } else if (foodType === 'invincible') {
                activateInvincibility();
            }
            foodIndex++; // Move to the next food item in the array
            if(foodIndex>=foods.length) return winLevel(); // Check if all foods for the level are eaten
        } else {
            snake.pop(); // Remove tail if no food eaten
        }
    }

    function gameLoop() {
        requestAnimationFrame(gameLoop);
        if(gameState==="playing" && canMove) {
            canMove = false;
            let delay = 300 - (currentLevel * 5);
            if (speedBoostActive) {
                delay /= 2;
            }
            delay = Math.max(100, delay);
            setTimeout(()=>{canMove=true;}, delay);
            update();
        }
        drawGame();
    }
    
    // --- Level Management ---
    function initLevel(levelIndex, resetScore = false) { // Added resetScore parameter
        hideMessage();
        currentLevel = levelIndex;
        const level = LEVELS[levelIndex];
        snake = JSON.parse(JSON.stringify(level.snake));
        foods = JSON.parse(JSON.stringify(level.foods));
        foodIndex = 0; // Always start from the first food item for the level
        dx = 0; dy = 0;
        canMove = true;
        levelDisplay.textContent = `Level: ${levelIndex+1}`;
        gameState = 'playing';
        if (resetScore) { // Only reset score if starting a new game
            score = 0;
            currentScoreAtLevelStart = 0;
        } else {
            currentScoreAtLevelStart = score; // Save score before re-init to continue levels
        }
        score = currentScoreAtLevelStart; // Restore score for continuing levels
        updateScoreDisplay();
        clearInterval(gameTimer);
        clearTimeout(invincibleTimeout);
        clearTimeout(speedBoostTimeout);
        timeLeft = level.timeLimit;
        updateTimeDisplay();
        gameTimer = setInterval(() => {
            if (gameState === 'playing') {
                timeLeft--;
                updateTimeDisplay();
                if (timeLeft <= 0) {
                    endGame("Time's up!");
                }
            }
        }, 1000);
        isInvincible = false;
        speedBoostActive = false;
        pauseIcon.style.display = 'inline';
        playIcon.style.display = 'none';
        drawGame();
    }
    
    // --- Power-up Functions ---
    function activateSpeedBoost() {
        speedBoostActive = true;
        clearTimeout(speedBoostTimeout);
        speedBoostTimeout = setTimeout(() => {
            speedBoostActive = false;
        }, 5000);
    }

    function activateInvincibility() {
        isInvincible = true;
        clearTimeout(invincibleTimeout);
        invincibleTimeout = setTimeout(() => {
            isInvincible = false;
        }, 7000);
    }

    // --- Input Handling ---
    function handleKeyDown(e) {
        if(gameState!=='playing') {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
            return;
        }
        switch(e.key) {
            case 'ArrowUp': case 'w': if(dy !== 1){dx=0;dy=-1;} break;
            case 'ArrowDown': case 's': if(dy !== -1){dx=0;dy=1;} break;
            case 'ArrowLeft': case 'a': if(dx !== 1){dx=-1;dy=0;} break;
            case 'ArrowRight': case 'd': if(dx !== -1){dx=1;dy=0;} break;
            case 'p': case 'P': togglePause(); break;
        }
    }

    function handleDpadClick(direction) {
        if(gameState!=='playing') return;
        switch(direction) {
            case 'up': if(dy !== 1){dx=0;dy=-1;} break;
            case 'down': if(dy !== -1){dx=0;dy=1;} break;
            case 'left': if(dx !== 1){dx=-1;dy=0;} break;
            case 'right': if(dx !== -1){dx=1;dy=0;} break;
        }
    }
    
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
        if(gameState!=='playing') return;
        if(e.touches.length===1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }
        // Resume AudioContext on first touch
        if (!audioAutoplayInitiated && audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed on touchstart.');
                audioAutoplayInitiated = true;
            });
        }
    }, { passive: true });
    
    canvas.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

    canvas.addEventListener('touchend', e => {
        if(gameState!=='playing' || e.changedTouches.length === 0) return;
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const dxSwipe = touchEndX - touchStartX;
        const dySwipe = touchEndY - touchStartY;
        const threshold = 20;
        if(Math.abs(dxSwipe)>Math.abs(dySwipe)) {
            if(dxSwipe>threshold && dx !== -1) { dx=1; dy=0; }
            else if(dxSwipe<-threshold && dx !== 1) { dx=-1; dy=0; }
        } else {
            if(dySwipe>threshold && dy !== -1) { dx=0; dy=1; }
            else if(dySwipe<-threshold && dy !== 1) { dx=0; dy=-1; }
        }
    }, { passive: false });

    // --- UI Functions ---
    function updateScoreDisplay() {
        scoreDisplay.textContent = `Score: ${score}`;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('veganCobraHighScore', highScore); // Updated localStorage key
        }
    }

    function updateTimeDisplay() {
        timeDisplay.textContent = `Time: ${timeLeft}s`;
    }

    function showMessage(title, text, buttons=[]) {
        messageTitle.textContent = title;
        messageText.innerHTML = text;
        messageButtons.innerHTML = '';
        buttons.forEach(btn=>{
            const b = document.createElement('button');
            b.textContent = btn.text;
            b.className = 'modal-button';
            b.onclick = btn.onClick;
            messageButtons.appendChild(b);
        });
        // Add listener to new modal buttons
        messageButtons.querySelectorAll('.modal-button').forEach(button => {
            button.addEventListener('click', () => {
                playSound(touchSound); // Play sound on button click
                // Resume AudioContext on any button click
                if (!audioAutoplayInitiated && audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed on button click.');
                        audioAutoplayInitiated = true;
                    });
                }
            });
        });
        messageOverlay.style.display = 'flex';
    }
    function hideMessage() {
        messageOverlay.style.display = 'none';
    }
    
    function endGame(reason) {
        playSound(gameOverSound);
        gameState = 'gameOver';
        clearInterval(gameTimer);
        clearTimeout(invincibleTimeout);
        clearTimeout(speedBoostTimeout);
        pauseIcon.style.display = 'none';
        playIcon.style.display = 'inline';
        showMessage("Game Over!", `${reason}<br>Your Score: ${score}<br>High Score: ${highScore}`, [
            {text:'Retry Level', onClick:()=>initLevel(currentLevel)},
            {text:'Play New Game', onClick:()=>initLevel(0, true)} // Pass true to reset score
        ]);
    }
    
    function winLevel() {
        playSound(winSound);
        gameState = 'paused';
        clearInterval(gameTimer);
        clearTimeout(invincibleTimeout);
        clearTimeout(speedBoostTimeout);
        pauseIcon.style.display = 'none';
        playIcon.style.display = 'inline';
        currentScoreAtLevelStart = score; // Save score before advancing
        const nextLevel = currentLevel+1;
        if(nextLevel<LEVELS.length) {
            showMessage("Yummy!", `You completed Level ${currentLevel+1}! Your Score: ${score}`, [
                {text:'Next Level', onClick:()=>initLevel(nextLevel)}
            ]);
        } else {
            showMessage("All Levels Cleared!", `Congratulations! You finished all ${LEVELS.length} stages!<br>Your Final Score: ${score}<br>High Score: ${highScore}`, [
                {text:'Play Again', onClick:()=>initLevel(0, true)} // Pass true to reset score
            ]);
        }
    }

    function togglePause() {
        if (gameState === 'playing') {
            gameState = 'paused';
            clearInterval(gameTimer);
            pauseIcon.style.display = 'none';
            playIcon.style.display = 'inline';
            showMessage("Game Paused", "Press Resume to continue.", [
                {text: 'Resume', onClick: togglePause},
                {text: 'Home', onClick: () => window.location.reload()}
            ]);
        } else if (gameState === 'paused') {
            gameState = 'playing';
            gameTimer = setInterval(() => {
                if (gameState === 'playing') {
                    timeLeft--;
                    updateTimeDisplay();
                    if (timeLeft <= 0) {
                        endGame("Time's up!");
                    }
                }
            }, 1000);
            pauseIcon.style.display = 'inline';
            playIcon.style.display = 'none';
            hideMessage();
        }
    }
    
    function showStartScreen() {
        gameState = 'start';
        clearInterval(gameTimer);
        clearTimeout(invincibleTimeout);
        clearTimeout(speedBoostTimeout);
        pauseIcon.style.display = 'none';
        playIcon.style.display = 'inline';
        showMessage("Vegan Cobra", `Eat all the delicious food and veggies in order.<br>Use <b>Arrow Keys</b>, <b>Swipe</b>, or the <b>on-screen buttons</b> to move.<br>High Score: ${highScore}`, [ // Updated game description
            {text:'Start Game', onClick:()=>initLevel(0, true)} // Pass true to reset score for a new game
        ]);
        drawGame();
    }
    
    // --- Sound ---
    function playSound(sound) {
        if(soundEnabled && sound) {
            // Ensure AudioContext is resumed if suspended (common browser policy)
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed during playSound call.');
                    audioAutoplayInitiated = true;
                    sound.currentTime = 0; // Rewind to start
                    sound.play().catch(error => {
                        console.warn("Audio playback prevented after resume attempt:", sound.id, error);
                    });
                });
            } else {
                sound.currentTime = 0; // Rewind to start
                sound.play().catch(error => {
                    // This catch block handles cases where autoplay is prevented initially
                    // or if there's another playback error.
                    console.warn("Audio playback prevented:", sound.id, error);
                });
            }
        }
    }
    
    // --- Event Listeners ---
    function resizeCanvas() {
        const wrapper = document.querySelector('.responsive-canvas-wrapper');
        let size = wrapper.offsetWidth;
        if (window.innerWidth > window.innerHeight && window.innerWidth <= 900) {
            size = wrapper.offsetHeight;
        }
        const dpr = window.devicePixelRatio || 1;
        canvas.width = size * dpr;
        canvas.height = size * dpr;
        canvas.style.width = `${size}px`;
        canvas.style.height = `${size}px`;
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform before scaling
        ctx.scale(dpr, dpr);
        drawGame();
    }
    
    settingsButton.addEventListener('click', (e) => {
        e.stopPropagation();
        playSound(touchSound); // Play sound on settings button click
        settingsMenu.style.display = settingsMenu.style.display === 'flex' ? 'none' : 'flex';
        // Resume AudioContext on any button click
        if (!audioAutoplayInitiated && audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed on settings button click.');
                audioAutoplayInitiated = true;
            });
        }
    });

    document.addEventListener('click', (e) => {
        if (!settingsMenu.contains(e.target) && e.target !== settingsButton && e.target !== pauseButton && !pauseButton.contains(e.target)) {
            settingsMenu.style.display = 'none';
        }
    });

    soundButton.addEventListener('click', ()=>{
        soundEnabled = !soundEnabled;
        soundOnIcon.style.display = soundEnabled ? 'inline' : 'none';
        soundOffIcon.style.display = soundEnabled ? 'none' : 'inline';
        playSound(touchSound); // Play sound for the toggle itself
        // If sound was just enabled, try to resume AudioContext
        if (soundEnabled && audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed on sound enable toggle.');
                audioAutoplayInitiated = true;
            });
        }
    });

    homeButton.addEventListener('click', () => {
        playSound(touchSound); // Play sound on home button click
        window.location.reload();
    });

    shareButton.addEventListener('click', () => {
        playSound(touchSound); // Play sound on share button click
        if (navigator.share) {
            navigator.share({
                title: 'Vegan Cobra', // Updated title for sharing
                text: 'Check out this cool snake game!',
                url: window.location.href,
            }).catch(console.error);
        } else {
             showMessage("Share", "Sharing isn't supported on this browser. You can copy the URL to share!", [{text: 'Close', onClick: hideMessage}]);
        }
    });
    
    // Add touch sounds to all buttons (ensure it's not double-added)
    document.querySelectorAll('button').forEach(button => {
        // Only add a generic click listener if it doesn't already have one
        // and is not one of the modal buttons (handled by showMessage)
        if (button.id !== 'settingsButton' && button.id !== 'soundButton' &&
            button.id !== 'homeButton' && button.id !== 'shareButton' &&
            button.id !== 'pauseButton' && button.id !== 'resetButton' &&
            !button.classList.contains('modal-button')
        ) {
            button.addEventListener('click', () => {
                playSound(touchSound);
                // Resume AudioContext on any button click
                if (!audioAutoplayInitiated && audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed on generic button click.');
                        audioAutoplayInitiated = true;
                    });
                }
            });
        }
    });

    resetButton.addEventListener('click', ()=>{
        playSound(touchSound); // Play sound on reset click
        if(gameState==='playing'||gameState==='gameOver'||gameState==='paused'){initLevel(currentLevel)}
    });
    document.addEventListener('keydown', handleKeyDown);
    dpadUp.addEventListener('click', () => { playSound(touchSound); handleDpadClick('up'); });
    dpadDown.addEventListener('click', () => { playSound(touchSound); handleDpadClick('down'); });
    dpadLeft.addEventListener('click', () => { playSound(touchSound); handleDpadClick('left'); });
    dpadRight.addEventListener('click', () => { playSound(touchSound); handleDpadClick('right'); });
    pauseButton.addEventListener('click', () => { playSound(touchSound); togglePause(); });
    window.addEventListener('resize', resizeCanvas);

    // --- Initialization ---
    window.onload = () => {
        // Initialize AudioContext
        if (window.AudioContext || window.webkitAudioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // Attempt to resume if it's suspended (common on page load without user gesture)
            if (audioContext.state === 'suspended') {
                // Attach a one-time listener to resume on first interaction
                const resumeAudio = () => {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(() => {
                            console.log('AudioContext resumed on initial user interaction (document click/keydown).');
                            audioAutoplayInitiated = true;
                        });
                    }
                    document.removeEventListener('click', resumeAudio);
                    document.removeEventListener('keydown', resumeAudio);
                    document.removeEventListener('touchstart', resumeAudio);
                };
                document.addEventListener('click', resumeAudio, { once: true });
                document.addEventListener('keydown', resumeAudio, { once: true });
                document.addEventListener('touchstart', resumeAudio, { once: true });
            } else {
                audioAutoplayInitiated = true; // Context is already running
            }
        } else {
            console.warn('Web Audio API not supported in this browser.');
            soundEnabled = false; // Disable sound if API not supported
            soundOnIcon.style.display = 'none';
            soundOffIcon.style.display = 'inline';
        }

        currentLevel = 0;
        resizeCanvas();
        showStartScreen();
        gameLoop();
    };
    </script>
    <a href="./" class="vegan cobra"></a>
</body>
</html>
